name: Upstream Sync

on:
  schedule:
    # Run daily at 06:00 UTC
    - cron: '0 6 * * *'
  workflow_dispatch:

jobs:
  check-upstream:
    name: Check for upstream changes
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get last synced commit
        id: last-sync
        run: |
          LAST_SYNC=$(cat .last-sync-commit | tr -d '[:space:]')
          echo "sha=$LAST_SYNC" >> "$GITHUB_OUTPUT"
          echo "Last synced upstream commit: $LAST_SYNC"

      - name: Get latest upstream commit
        id: upstream
        run: |
          # Use git ls-remote to query the public upstream repo — no API calls or auth needed
          LATEST=$(git ls-remote https://github.com/mapbox/earcut.git refs/heads/main | cut -f1)
          if [ -z "$LATEST" ]; then
            echo "::error::Could not resolve latest upstream commit SHA"
            exit 1
          fi
          echo "sha=$LATEST" >> "$GITHUB_OUTPUT"
          echo "Latest upstream commit: $LATEST"

      - name: Check if sync is needed
        id: check
        run: |
          LAST="${{ steps.last-sync.outputs.sha }}"
          LATEST="${{ steps.upstream.outputs.sha }}"
          if [ "$LAST" = "$LATEST" ]; then
            echo "needed=false" >> "$GITHUB_OUTPUT"
            echo "Already up to date with upstream ($LATEST)."
          else
            echo "needed=true" >> "$GITHUB_OUTPUT"
            echo "Upstream has new commits since $LAST (latest: $LATEST)."
          fi

      - name: Clone upstream repository
        if: steps.check.outputs.needed == 'true'
        run: |
          LATEST="${{ steps.upstream.outputs.sha }}"
          # Shallow-clone main of the public upstream repo — no auth required
          git clone --depth 50 https://github.com/mapbox/earcut.git /tmp/earcut-upstream
          echo "Cloned upstream at $LATEST"
          echo "Upstream files:"
          find /tmp/earcut-upstream -not -path '/tmp/earcut-upstream/.git/*' -type f | sort

      - name: Build commit list for PR body
        if: steps.check.outputs.needed == 'true'
        id: diff
        run: |
          LAST="${{ steps.last-sync.outputs.sha }}"
          LATEST="${{ steps.upstream.outputs.sha }}"

          # Use git log to list commits between last-sync and latest — pure git, no API calls
          COMMITS=$(git -C /tmp/earcut-upstream log \
            --pretty=format:"- [%h](https://github.com/mapbox/earcut/commit/%H) %s" \
            "${LAST}..${LATEST}" 2>/dev/null || echo "- (could not retrieve commit list)")

          if [ -z "$COMMITS" ]; then
            COMMITS="- (no commits found)"
          fi

          echo "COMMITS<<EOF" >> "$GITHUB_OUTPUT"
          echo "$COMMITS" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Create sync branch and PR
        if: steps.check.outputs.needed == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          LAST="${{ steps.last-sync.outputs.sha }}"
          LATEST="${{ steps.upstream.outputs.sha }}"
          BRANCH="auto-sync/upstream-${LATEST:0:7}"
          DATE=$(date -u +"%Y-%m-%d")

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create a new branch from main
          git checkout -b "$BRANCH"

          # Update the .last-sync-commit file
          echo "$LATEST" > .last-sync-commit

          # Mirror ALL upstream source files into .upstream/ so reviewers and
          # Copilot can see every changed file side-by-side with the C# port
          rm -rf .upstream
          mkdir -p .upstream
          rsync -a --exclude='.git' /tmp/earcut-upstream/ .upstream/

          git add .last-sync-commit .upstream/
          git commit -m "chore: update upstream sync to ${LATEST:0:7}

Upstream commits since ${LAST:0:7}:
${{ steps.diff.outputs.COMMITS }}"

          git push origin "$BRANCH"

          # Ensure the auto-sync label exists
          gh label create "auto-sync" \
            --description "Automatically generated upstream sync PR" \
            --color "0075ca" \
            --repo "${{ github.repository }}" 2>/dev/null || true

          # Create the pull request
          gh pr create \
            --title "chore: sync upstream earcut changes (${LATEST:0:7}) — ${DATE}" \
            --body "## Upstream Sync

This PR was automatically generated by the [Upstream Sync workflow](.github/workflows/upstream-sync.yml).

**Upstream repository:** https://github.com/mapbox/earcut  
**Previous synced commit:** [\`${LAST:0:7}\`](https://github.com/mapbox/earcut/commit/${LAST})  
**New upstream commit:** [\`${LATEST:0:7}\`](https://github.com/mapbox/earcut/commit/${LATEST})  
**Compare:** https://github.com/mapbox/earcut/compare/${LAST}...${LATEST}

### Upstream commits included

${{ steps.diff.outputs.COMMITS }}

### What to do

The complete upstream repository at the new commit has been mirrored into \`.upstream/\` so you can diff every changed file side-by-side:

1. Review the full upstream diff: https://github.com/mapbox/earcut/compare/${LAST}...${LATEST}
2. Port algorithm changes from \`.upstream/src/earcut.js\` to \`src/Earcut/Earcut.cs\` using [PORTING_GUIDE.md](PORTING_GUIDE.md).
3. If test fixtures were added/changed in \`.upstream/test/fixtures/\`, copy them to \`test/Earcut.Tests/fixtures/\` and update \`test/Earcut.Tests/expected.json\`.
4. Run \`dotnet test\` and ensure all tests pass.
5. Update \`PORTING_GUIDE.md\` if new language patterns were introduced.

> [!NOTE]
> GitHub Copilot coding agent can be invoked on this PR to assist with porting the JS changes to C#." \
            --label "auto-sync" \
            --base main \
            --head "$BRANCH" \
            --repo "${{ github.repository }}"
